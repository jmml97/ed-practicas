<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Stack Max: Referencia de la Clase StackMax</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Stack Max
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generado por Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Página&#160;principal</span></a></li>
      <li><a href="pages.html"><span>Páginas&#160;relacionadas</span></a></li>
      <li class="current"><a href="annotated.html"><span>Clases</span></a></li>
      <li><a href="files.html"><span>Archivos</span></a></li>
      <li><a href="examples.html"><span>Ejemplos</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Lista&#160;de&#160;clases</span></a></li>
      <li><a href="classes.html"><span>Índice&#160;de&#160;clases</span></a></li>
      <li><a href="functions.html"><span>Miembros&#160;de&#160;las&#160;clases</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classStackMax.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Métodos públicos</a> &#124;
<a href="#pri-attribs">Atributos privados</a> &#124;
<a href="#related">Funciones relacionadas</a> &#124;
<a href="classStackMax-members.html">Lista de todos los miembros</a>  </div>
  <div class="headertitle">
<div class="title">Referencia de la Clase StackMax</div>  </div>
</div><!--header-->
<div class="contents">

<p>T.D.A. <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>.  
 <a href="classStackMax.html#details">Más...</a></p>

<p><code>#include &lt;<a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Métodos públicos</h2></td></tr>
<tr class="memitem:adf2a27f72905af9539821223661a5680"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#adf2a27f72905af9539821223661a5680">StackMax</a> ()</td></tr>
<tr class="memdesc:adf2a27f72905af9539821223661a5680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor por defecto.  <a href="#adf2a27f72905af9539821223661a5680">Más...</a><br /></td></tr>
<tr class="separator:adf2a27f72905af9539821223661a5680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16cfce276ed719d1a4f479c016bb05dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structElement.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a16cfce276ed719d1a4f479c016bb05dd">top</a> ()</td></tr>
<tr class="memdesc:a16cfce276ed719d1a4f479c016bb05dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el elemento del tope de la cola.  <a href="#a16cfce276ed719d1a4f479c016bb05dd">Más...</a><br /></td></tr>
<tr class="separator:a16cfce276ed719d1a4f479c016bb05dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6389d8194868901ecc75f11875e66817"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structElement.html">Element</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a6389d8194868901ecc75f11875e66817">top</a> () const </td></tr>
<tr class="memdesc:a6389d8194868901ecc75f11875e66817"><td class="mdescLeft">&#160;</td><td class="mdescRight">Devuelve el elemento del tope de la cola.  <a href="#a6389d8194868901ecc75f11875e66817">Más...</a><br /></td></tr>
<tr class="separator:a6389d8194868901ecc75f11875e66817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18b23430116284fbfcfa722bbf0ff8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a18b23430116284fbfcfa722bbf0ff8dd">push</a> (int n)</td></tr>
<tr class="memdesc:a18b23430116284fbfcfa722bbf0ff8dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Añade un elemento a la pila.  <a href="#a18b23430116284fbfcfa722bbf0ff8dd">Más...</a><br /></td></tr>
<tr class="separator:a18b23430116284fbfcfa722bbf0ff8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a913a5cba363797ad6461040463a6ca63"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a913a5cba363797ad6461040463a6ca63">pop</a> ()</td></tr>
<tr class="memdesc:a913a5cba363797ad6461040463a6ca63"><td class="mdescLeft">&#160;</td><td class="mdescRight">Elimina el elemento del tope.  <a href="#a913a5cba363797ad6461040463a6ca63">Más...</a><br /></td></tr>
<tr class="separator:a913a5cba363797ad6461040463a6ca63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19055338df7249e98f3842217e56f86"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab19055338df7249e98f3842217e56f86"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#ab19055338df7249e98f3842217e56f86">clear</a> ()</td></tr>
<tr class="memdesc:ab19055338df7249e98f3842217e56f86"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borra la pila completamente. <br /></td></tr>
<tr class="separator:ab19055338df7249e98f3842217e56f86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba5a28c92d8cbe4e51b8ed375ccd27d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a1ba5a28c92d8cbe4e51b8ed375ccd27d">size</a> () const </td></tr>
<tr class="memdesc:a1ba5a28c92d8cbe4e51b8ed375ccd27d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consulta el tamaño de la pila.  <a href="#a1ba5a28c92d8cbe4e51b8ed375ccd27d">Más...</a><br /></td></tr>
<tr class="separator:a1ba5a28c92d8cbe4e51b8ed375ccd27d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14efc7031efe24b64d5d96b5067412a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a14efc7031efe24b64d5d96b5067412a6">empty</a> () const </td></tr>
<tr class="memdesc:a14efc7031efe24b64d5d96b5067412a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consulta si la pila está vacía.  <a href="#a14efc7031efe24b64d5d96b5067412a6">Más...</a><br /></td></tr>
<tr class="separator:a14efc7031efe24b64d5d96b5067412a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658ecfb247b3a244f600c1e1375ea741"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a658ecfb247b3a244f600c1e1375ea741">sameMax</a> (const <a class="el" href="classStackMax.html">StackMax</a> &amp;s) const </td></tr>
<tr class="memdesc:a658ecfb247b3a244f600c1e1375ea741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Consulta si dos pilass tienen el mismo máximo.  <a href="#a658ecfb247b3a244f600c1e1375ea741">Más...</a><br /></td></tr>
<tr class="separator:a658ecfb247b3a244f600c1e1375ea741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35e9c174db9359f25dbac7dddcff090"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#ab35e9c174db9359f25dbac7dddcff090">loadStack</a> (std::istream &amp;is)</td></tr>
<tr class="memdesc:ab35e9c174db9359f25dbac7dddcff090"><td class="mdescLeft">&#160;</td><td class="mdescRight">Carga una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> desde un flujo de entrada.  <a href="#ab35e9c174db9359f25dbac7dddcff090">Más...</a><br /></td></tr>
<tr class="separator:ab35e9c174db9359f25dbac7dddcff090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d8c6dbe952fc37dd25b8ced89ebe4e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#aa1d8c6dbe952fc37dd25b8ced89ebe4e">writeStack</a> (std::ostream &amp;os) const </td></tr>
<tr class="memdesc:aa1d8c6dbe952fc37dd25b8ced89ebe4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escribe una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> en un flujo de salida.  <a href="#aa1d8c6dbe952fc37dd25b8ced89ebe4e">Más...</a><br /></td></tr>
<tr class="separator:aa1d8c6dbe952fc37dd25b8ced89ebe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58d3f543863681839e85813d3ecb49ed"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a58d3f543863681839e85813d3ecb49ed">prettyPrint</a> (std::ostream &amp;os=std::cout) const </td></tr>
<tr class="memdesc:a58d3f543863681839e85813d3ecb49ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escribe una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> en un flujo de salida.  <a href="#a58d3f543863681839e85813d3ecb49ed">Más...</a><br /></td></tr>
<tr class="separator:a58d3f543863681839e85813d3ecb49ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Atributos privados</h2></td></tr>
<tr class="memitem:a9cc3b7f8d6088695cfd69b53de572a46"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9cc3b7f8d6088695cfd69b53de572a46"></a>
<a class="el" href="classDVector.html">StackType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a9cc3b7f8d6088695cfd69b53de572a46">v</a></td></tr>
<tr class="memdesc:a9cc3b7f8d6088695cfd69b53de572a46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Representación interna de la pila. <br /></td></tr>
<tr class="separator:a9cc3b7f8d6088695cfd69b53de572a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Funciones relacionadas</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Observar que estas no son funciones miembro.) </p>
</td></tr>
<tr class="memitem:a3bf356b3b2f26a2819fb927f3c969ed3"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a3bf356b3b2f26a2819fb927f3c969ed3">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="classStackMax.html">StackMax</a> &amp;s)</td></tr>
<tr class="memdesc:a3bf356b3b2f26a2819fb927f3c969ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sobrecarga del operador &gt;&gt; para <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>.  <a href="#a3bf356b3b2f26a2819fb927f3c969ed3">Más...</a><br /></td></tr>
<tr class="separator:a3bf356b3b2f26a2819fb927f3c969ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28f4529f3e50e22d9a0500b60d2833d8"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classStackMax.html#a28f4529f3e50e22d9a0500b60d2833d8">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classStackMax.html">StackMax</a> &amp;s)</td></tr>
<tr class="memdesc:a28f4529f3e50e22d9a0500b60d2833d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sobrecarga del operador &lt;&lt; para <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>.  <a href="#a28f4529f3e50e22d9a0500b60d2833d8">Más...</a><br /></td></tr>
<tr class="separator:a28f4529f3e50e22d9a0500b60d2833d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Descripción detallada</h2>
<div class="textblock"><p>T.D.A. <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>. </p>
<p>Una instancia <em>s</em> del tipo de datos abstracto <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> es un objeto que representa una pila de objetos de tipo <a class="el" href="structElement.html" title="T.D.A. Element. ">Element</a>. Está compuesto por una estructura de datos (<code>StackType</code>) <em>v</em>, que puede ser una de tres: un vector dinámico, una lista con cabecera ó una cola. Este dato constituye la representación interna de la pila. Una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> de longitud <em>k</em> la denotamos:</p>
<blockquote class="doxtable">
<p>&lt;(num_1,max_1),(num_2, max_2),...,(num_k, max_k)&gt; </p>
</blockquote>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="classList.html" title="T.D.A. List. ">List</a> </dd>
<dd>
<a class="el" href="classDVector.html" title="T.D.A. DVector. ">DVector</a> </dd>
<dd>
<a class="el" href="classQueue.html" title="T.D.A. Queue. ">Queue</a></dd></dl>
<dl class="section author"><dt>Autor</dt><dd>Antonio Coín Castro </dd>
<dd>
Miguel Lentisco Ballesteros </dd>
<dd>
José María Martín Luque </dd></dl>
<dl class="section date"><dt>Fecha</dt><dd>Noviembre 2016 </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#_a0">use_stack_max.cpp</a>.</dd>
</dl>
<p>Definición en la línea <a class="el" href="stack__max_8hpp_source.html#l00096">96</a> del archivo <a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a>.</p>
</div><h2 class="groupheader">Documentación del constructor y destructor</h2>
<a class="anchor" id="adf2a27f72905af9539821223661a5680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">StackMax::StackMax </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor por defecto. </p>
<dl class="section post"><dt>Postcondición</dt><dd>Construye una pila vacía </dd></dl>

<p>Definición en la línea <a class="el" href="stack__max_8hpp_source.html#l00123">123</a> del archivo <a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones miembro</h2>
<a class="anchor" id="a14efc7031efe24b64d5d96b5067412a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool StackMax::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consulta si la pila está vacía. </p>
<dl class="retval"><dt>Valores devueltos</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Si está vacía </td></tr>
    <tr><td class="paramname">false</td><td>Si no está vacía </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a3">use_stack_max.cpp</a>.</dd>
</dl>
<p>Definición en la línea <a class="el" href="stack__max_8hpp_source.html#l00175">175</a> del archivo <a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a>.</p>

<p>Hace referencia a <a class="el" href="dvector_8hpp_source.html#l00226">DVector&lt; T &gt;::empty()</a> y <a class="el" href="structElement.html#aa7ae5f08a9fd941c9e7b1996de57cf96">Element::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a class="anchor" id="ab35e9c174db9359f25dbac7dddcff090"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::istream&amp; StackMax::loadStack </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Carga una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> desde un flujo de entrada. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Flujo de entrada </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondición</dt><dd>Hay dos formatos de lectura. En ambos, el tope de la pila es el que se encuentra más arriba.</dd></dl>
<ul>
<li>Formato 1: <pre class="fragment">n1 max1
n2 max2
n3 max3
...
</pre></li>
<li>Formato 2: <pre class="fragment">$
n1
n2
n3
...
</pre></li>
</ul>
<p>El segundo formato necesita el símbolo '$' al inicio del archivo para ser reconocido como un formato válido de entrada. El primer formato se mantiene por compatibilidad con el formato de escritura, aunque los diferentes máximos son ignorados en la lectura.</p>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="classStackMax.html#aa1d8c6dbe952fc37dd25b8ced89ebe4e" title="Escribe una StackMax en un flujo de salida. ">writeStack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a913a5cba363797ad6461040463a6ca63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StackMax::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Elimina el elemento del tope. </p>
<dl class="section pre"><dt>Precondición</dt><dd>La pila no es vacía </dd></dl>
<dl class="section post"><dt>Postcondición</dt><dd>El tamaño de la pila disminuye en 1 </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a6">use_stack_max.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a58d3f543863681839e85813d3ecb49ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; StackMax::prettyPrint </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em> = <code>std::cout</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escribe una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> en un flujo de salida. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Flujo de salida. Por defecto es std::cout </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondición</dt><dd>El formato de escritura es el siguiente: <pre class="fragment">(n1,max1)
(n2,max2)
(n3,max3)
...</pre> </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a7">use_stack_max.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a18b23430116284fbfcfa722bbf0ff8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void StackMax::push </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Añade un elemento a la pila. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>Entero usado para crear el elemento a añadir </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondición</dt><dd>El tamaño de la pila aumenta en 1 </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a2">use_stack_max.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a658ecfb247b3a244f600c1e1375ea741"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool StackMax::sameMax </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classStackMax.html">StackMax</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Consulta si dos pilass tienen el mismo máximo. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pila para comparar con el objeto implícito </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondición</dt><dd>Tanto el objeto implícito como <em>s</em> son pilas no vacías. </dd></dl>
<dl class="retval"><dt>Valores devueltos</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>Si tienen el mismo máximo </td></tr>
    <tr><td class="paramname">false</td><td>Si no tienen el mismo máximo. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a8">use_stack_max.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a1ba5a28c92d8cbe4e51b8ed375ccd27d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int StackMax::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Consulta el tamaño de la pila. </p>
<dl class="section return"><dt>Devuelve</dt><dd>Tamaño de la pila (0 si es vacía) </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a1">use_stack_max.cpp</a>.</dd>
</dl>
<p>Definición en la línea <a class="el" href="stack__max_8hpp_source.html#l00168">168</a> del archivo <a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a>.</p>

<p>Hace referencia a <a class="el" href="dvector_8hpp_source.html#l00213">DVector&lt; T &gt;::size()</a>.</p>

</div>
</div>
<a class="anchor" id="a16cfce276ed719d1a4f479c016bb05dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structElement.html">Element</a>&amp; StackMax::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el elemento del tope de la cola. </p>
<dl class="section pre"><dt>Precondición</dt><dd>La pila no es vacía </dd></dl>
<dl class="section return"><dt>Devuelve</dt><dd>Referencia al elemento del tope </dd></dl>
<dl><dt><b>Ejemplos: </b></dt><dd><a class="el" href="use_stack_max_8cpp-example.html#a5">use_stack_max.cpp</a>.</dd>
</dl>
</div>
</div>
<a class="anchor" id="a6389d8194868901ecc75f11875e66817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structElement.html">Element</a>&amp; StackMax::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Devuelve el elemento del tope de la cola. </p>
<dl class="section pre"><dt>Precondición</dt><dd>La pila no es vacía </dd></dl>
<dl class="section return"><dt>Devuelve</dt><dd>Referencia constante al elemento del tope </dd></dl>

</div>
</div>
<a class="anchor" id="aa1d8c6dbe952fc37dd25b8ced89ebe4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; StackMax::writeStack </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escribe una <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> en un flujo de salida. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Flujo de salida </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondición</dt><dd>El formato de escritura es el siguiente: <pre class="fragment">n1 max1
n2 max2
n3 max3
...
</pre></dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="classStackMax.html#ab35e9c174db9359f25dbac7dddcff090" title="Carga una StackMax desde un flujo de entrada. ">loadStack</a> </dd></dl>

</div>
</div>
<h2 class="groupheader">Documentación de las funciones relacionadas y clases amigas</h2>
<a class="anchor" id="a28f4529f3e50e22d9a0500b60d2833d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classStackMax.html">StackMax</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sobrecarga del operador &lt;&lt; para <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td>Flujo de salida </td></tr>
    <tr><td class="paramname">s</td><td>Pila a escribir </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondición</dt><dd>El formato de escritura es el especificado en la documentación de <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a></dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="classStackMax.html#aa1d8c6dbe952fc37dd25b8ced89ebe4e" title="Escribe una StackMax en un flujo de salida. ">StackMax::writeStack</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a3bf356b3b2f26a2819fb927f3c969ed3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::istream &amp; operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>is</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classStackMax.html">StackMax</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sobrecarga del operador &gt;&gt; para <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>. </p>
<dl class="params"><dt>Parámetros</dt><dd>
  <table class="params">
    <tr><td class="paramname">is</td><td>Flujo de entrada </td></tr>
    <tr><td class="paramname">s</td><td>Pila donde leer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondición</dt><dd>El formato de lectura es el especificado en la documentación de <a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a>. </dd></dl>
<dl class="section post"><dt>Postcondición</dt><dd><a class="el" href="classStackMax.html" title="T.D.A. StackMax. ">StackMax</a> leída en <em>s</em> </dd></dl>
<dl class="section see"><dt>Ver también</dt><dd><a class="el" href="classStackMax.html#ab35e9c174db9359f25dbac7dddcff090" title="Carga una StackMax desde un flujo de entrada. ">StackMax::loadStack</a> </dd></dl>

</div>
</div>
<hr/>La documentación para esta clase fue generada a partir del siguiente fichero:<ul>
<li>include/<a class="el" href="stack__max_8hpp_source.html">stack_max.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<hr>
<small>ETS Ingeniería Informática y Telecomunicaciones. Universidad de Granada.
</small>
